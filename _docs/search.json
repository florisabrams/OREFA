[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OREFA",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "OREFA",
    "section": "Install",
    "text": "Install\npip install OREFA"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "OREFA",
    "section": "How to use",
    "text": "How to use\nFill me in please! Donâ€™t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "data_ingestion.html",
    "href": "data_ingestion.html",
    "title": "Data ingestion of crop, soil and deposition data within area of interest",
    "section": "",
    "text": "Point depostion data to Deposition on parcel\nA Point based depsoiton file as input will be used to find the deposition data on each parcel\n\nimport os\nimport random\nimport math\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\n\nclass Point():\n    def __init__(self, id, x, y, z):\n        self.id = id\n        self.x = x\n        self.y = y\n        self.z = z\n\n\nclass Vertex():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Extension:\n    def __init__(self, xmin, ymin, xmax, ymax, circular=False):\n        self.xmax = xmax\n        self.xmin = xmin\n        self.ymax = ymax\n        self.ymin = ymin\n        self.dx = xmax - xmin\n        self.dy = ymax - ymin\n        self.circular = circular;\n        self.radius = 0\n        self.xc = (self.xmax + self.xmin) * 0.5\n        self.yc = (self.ymax + self.ymin) * 0.5\n\n        if circular:\n            self.radius = math.sqrt(pow(self.dx, 2) + pow(self.dy, 2)) * 0.5\n\n        self.vertex = [Vertex(xmin, ymin),\n                       Vertex(xmax, ymin),\n                       Vertex(xmax, ymax),\n                       Vertex(xmin, ymax)]\n\n    def contains(self, point):\n\n        dist = 0\n        if self.circular:\n            dist = math.sqrt(pow(self.xc - point.x, 2) + pow(self.yc - point.y, 2))\n            if dist &lt;= self.radius:\n                return True\n\n        if (self.xmax &gt;= point.x and self.ymax &gt;= point.y and self.xmin &lt; point.x and self.ymin &lt; point.y):\n            return True\n        return False\n\n    def intersect(self, extension):\n\n        distv0 = 0\n        distv1 = 0\n        distv2 = 0\n        distv3 = 0\n\n        if extension.circular:\n            distv0 = math.sqrt(pow(extension.xc - self.xmin, 2) + pow(extension.yc - self.ymin, 2))\n            distv1 = math.sqrt(pow(extension.xc - self.xmax, 2) + pow(extension.yc - self.ymin, 2))\n            distv2 = math.sqrt(pow(extension.xc - self.xmax, 2) + pow(extension.yc - self.ymax, 2))\n            distv3 = math.sqrt(pow(extension.xc - self.xmin, 2) + pow(extension.yc - self.ymax, 2))\n\n            if self.contains(Point(0, extension.xmax, extension.yc, 0)):\n                return True\n            if self.contains(Point(0, extension.xc, extension.ymax, 0)):\n                return True\n            if self.contains(Point(0, extension.xmin, extension.yc, 0)):\n                return True\n            if self.contains(Point(0, extension.xc, extension.ymin, 0)):\n                return True\n            if self.contains(Point(0, extension.xc, extension.yc, 0)):\n                return True\n            if distv0 &lt;= extension.radius:\n                return True\n            if distv1 &lt;= extension.radius:\n                return True\n            if distv2 &lt;= extension.radius:\n                return True\n            if distv3 &lt;= extension.radius:\n                return True\n\n            return False\n\n        if not (extension.xmin &gt; self.xmax or\n                extension.xmax &lt; self.xmin or\n                extension.ymin &gt; self.ymax or\n                extension.ymax &lt; self.ymin):\n            return True\n\n\nclass QuadTree():\n\n    def __init__(self, extension, capacity):\n        self.extension = extension\n        self.capacity = capacity\n        self.points = [];\n        self.divided = False\n\n    def insertPoints(self, points):\n        for point in points:\n            self.insertPoint(point)\n\n    def insertPoint(self, point):\n\n        if not self.extension.contains(point):\n            return False\n\n        if len(self.points) &lt; self.capacity:\n            self.points.append(point)\n            return True\n        else:\n            if not self.divided:\n                self.subdivide()\n\n            if self.NW.insertPoint(point):\n                return True\n            elif self.NE.insertPoint(point):\n                return True\n            elif self.SE.insertPoint(point):\n                return True\n            elif self.SW.insertPoint(point):\n                return True\n\n    def subdivide(self):\n        exNE = Extension((self.extension.xmin + self.extension.xmax) * 0.5,\n                         (self.extension.ymin + self.extension.ymax) * 0.5,\n                         self.extension.xmax, self.extension.ymax)\n        exNW = Extension(self.extension.xmin,\n                         (self.extension.ymin + self.extension.ymax) * 0.5,\n                         (self.extension.xmin + self.extension.xmax) * 0.5, self.extension.ymax)\n        exSW = Extension(self.extension.xmin, self.extension.ymin, (self.extension.xmin + self.extension.xmax) * 0.5,\n                         (self.extension.ymin + self.extension.ymax) * 0.5)\n        exSE = Extension((self.extension.xmin + self.extension.xmax) * 0.5, self.extension.ymin,\n                         self.extension.xmax, (self.extension.ymin + self.extension.ymax) * 0.5)\n        self.NE = QuadTree(exNE, self.capacity)\n        self.NW = QuadTree(exNW, self.capacity)\n        self.SW = QuadTree(exSW, self.capacity)\n        self.SE = QuadTree(exSE, self.capacity)\n        self.divided = True\n\n    def select(self, extension):\n        found = []\n        return self.query(extension, found)\n\n    def query(self, extension, found=[]):\n\n        # if not found:\n        #   found=[]\n\n        if not self.extension.intersect(extension):\n            return\n        else:\n            for point in self.points:\n                if extension.contains(point):\n                    found.append(point)\n            if self.divided:\n                self.NE.query(extension, found)\n                self.NW.query(extension, found)\n                self.SW.query(extension, found)\n                self.SE.query(extension, found)\n        # print(len(found))\n        return found\n\n    # todo make circular\n    def Plot(self, extension=[], points=[]):\n        fig = plt.figure(figsize=(12, 8))\n        plt.title(\"Quadtree\")\n        ax = fig.add_subplot(111)\n        self.graph(ax)\n        if points:\n            x = [point.x for point in points]\n            y = [point.y for point in points]\n            plt.plot(x, y, 'bo')\n        if extension:\n            if extension.circular:\n                ax.add_patch(patches.Circle((extension.xc, extension.yc), extension.radius, fill=False, color='blue'))\n            else:\n                ax.add_patch(patches.Rectangle((extension.xmin, extension.ymin), extension.dx, extension.dy, fill=False,\n                                               color='blue'))\n        plt.show()\n\n    def graph(self, ax):\n\n        ax.add_patch(patches.Rectangle((self.extension.xmin, self.extension.ymin), self.extension.dx, self.extension.dy,\n                                       fill=False))\n        # print(len(self.points))\n        x = [point.x for point in self.points]\n        y = [point.y for point in self.points]\n        plt.plot(x, y, 'ro')\n\n        if (self.divided):\n            self.NE.graph(ax)\n            self.NW.graph(ax)\n            self.SW.graph(ax)\n            self.SE.graph(ax)\n        return\n\n\ndef select(extension, points):\n    pointList = []\n\n    for point in points:\n        if extension.contains(point):\n            pointList.append(point)\n    return pointList\n\n\ndef get_extension(country):\n    import fiona\n\n    with fiona.open(country, 'r') as extension_area:\n        extension_coor = extension_area.bounds\n        extension = Extension(extension_coor[0], extension_coor[1], extension_coor[2], extension_coor[3])\n        return extension\n\n\ndef prepare_points(depositon_path):\n    import fiona\n\n    points = []\n    with fiona.open(depositon_path, 'r') as deposition_points:\n        for point in deposition_points:\n            fid = int(point['id'])\n            # todo value Lambert_X en Lambert_Y\n            geom_x = point['geometry']['coordinates'][0]\n            geom_y = point['geometry']['coordinates'][1]\n            value_deposition = point['properties']['value']\n            dep_points = Point(fid, geom_x, geom_y, value_deposition)\n            points.append(dep_points)\n    return points\n\nInverse distance weight function to interpolate the depsotion value between points\n\ndef CalcIDWvalue(unknowncell, knowncells, sensitivity):\n    weighted_values_sum = 0.0\n    sum_of_weights = 0.0\n    neg_half_sens = -sensitivity/2.0\n    for knowncell in knowncells:\n        weight = ((unknowncell.x-knowncell.x)**2 + (unknowncell.y-knowncell.y)**2)**neg_half_sens\n        sum_of_weights += weight\n        weighted_values_sum += weight * knowncell.z\n    \n    return weighted_values_sum / sum_of_weights\n\nInterpolation mechanism\n\ndef interpol_deposition(res_intersection, qtree,distance_step=500, points_needed = 1, circular=True):\n\n\n    polygon_deposition_list = []\n\n\n    for index, polygon in res_intersection.iterrows():\n        centroid = polygon['geometry'].centroid\n\n        found = []\n        distance = 0\n        while len(found) &lt; points_needed:\n            #todo check if influence with far away polygon\n            if distance &gt; (float(distance_step)*10):\n                break\n            else:\n                # extension for the query\n                x0 = centroid.x - distance\n                x1 = centroid.x + distance\n                y0 = centroid.y - distance\n                y1 = centroid.y + distance\n\n                extQuery = Extension(min(x0, x1), min(y0, y1), max(x0, x1), max(y0, y1), circular)\n\n                found = qtree.select(extQuery)\n                distance += float(distance_step)\n\n\n        if len(found) &gt;= points_needed:\n            idw_value = CalcIDWvalue(unknowncell=centroid, knowncells=found, sensitivity=3)\n        else:\n            idw_value = 0\n\n        polygon_deposition_list.append(float(idw_value))\n\n    res_intersection['deposition'] = polygon_deposition_list\n\n    return res_intersection\n\n\ndef AOI_creation(config_path):\n    import geopandas as gpd\n    import json\n    import pandas as pd\n    import numpy as np\n    \n    # import the config file\n    import configparser\n    config = configparser.ConfigParser()\n    config.read(config_path)\n    \n    \n    # Data\n    AOI_path = config[\"DataSource\"][\"AOIPath\"]\n    soil_path = config[\"DataSource\"][\"SoilDataPath\"]\n    parcel_path = config[\"DataSource\"][\"ParcelDataPath\"]\n    deposition_path = config[\"DataSource\"][\"DepositionDataPath\"]\n    country = config[\"DataSource\"][\"country\"]\n\n    crop_dictionary =  config[\"ModelInputs\"][\"CropGroup\"]\n    crop_column = \"LBLHFDTLT\"\n    soil_dictionary =  config[\"ModelInputs\"][\"SoilGroup\"]\n    soil_column = \"Grove_leg\"\n    \n\n    deposition_interpolation_distance = 100\n\n    # get AOI\n\n    aoi_mask = gpd.read_file(AOI_path)\n    aoi_bbox = tuple(aoi_mask.total_bounds)\n\n\n    # get crops\n    complete_crop = gpd.read_file(parcel_path, encoding='utf-8', bbox=aoi_bbox)\n    crop = gpd.clip(complete_crop, aoi_mask, keep_geom_type=True)\n    \n    with open(crop_dictionary, 'r', encoding='utf-8') as dict:\n        aoi_specific_dictionary = json.load(dict)\n        crop['reclass_crop'] = crop[crop_column].replace(aoi_specific_dictionary)\n        AOI_crop = crop[['fid',crop_column,'reclass_crop','geometry']]\n    \n    # get soil\n    complete_soil = gpd.read_file(soil_path, encoding='utf-8', bbox=aoi_bbox)\n    soil = gpd.clip(complete_soil, aoi_mask, keep_geom_type=True)\n\n    with open(soil_dictionary, 'r', encoding='utf-8') as dict:\n        aoi_specific_dictionary = json.load(dict)\n        soil['reclass_soil'] = soil[soil_column].replace(aoi_specific_dictionary)\n        AOI_soil = soil[['fid',soil_column,'reclass_soil','geometry']]\n\n\n\n    # Merge Parcel with soils\n    soil_ind = AOI_soil\n    soil_ind.sindex\n\n    crop_ind = AOI_crop\n    crop_ind.sindex\n\n    # overlay much slower than sjoin\n    res_intersection = gpd.sjoin(crop_ind, soil_ind, predicate='intersects')\n\n    # dissolve to get the initial crop size parcels\n    res_intersection = res_intersection.dissolve(by='fid_left', aggfunc='first', as_index=False)\n    res_intersection = res_intersection[['fid_left', f'{crop_column}', 'reclass_crop',  f'{soil_column}', 'reclass_soil', 'geometry']]\n    res_intersection.columns = ['id', 'crop_type', 'crop_class', 'soil_type', 'soil_class', 'geometry']\n\n    # only real crops, exclude agr. infrastructure\n    df = res_intersection.replace(to_replace='None', value=np.nan).dropna()\n\n\n    # remove Multipolygon geometries\n    id_to_remove = []\n    for parcel in df.itertuples():\n        if parcel.geometry.geom_type == 'MultiPolygon':\n            id_to_remove.append(parcel.id)\n        else:\n            pass\n\n    df = df.query(f'id not in {id_to_remove}')\n    print(f'Parcels {id_to_remove} are removed froma AOI because of Multipolygon problems, inspect AOI borders')\n\n    # Deposition ofeach parcel\n    #country_shape = gpd.read_file(country)\n    extension = get_extension(country)\n    qtree = QuadTree(extension, 5000)\n    points = prepare_points(deposition_path)\n\n    qtree.insertPoints(points)\n\n    # todo check if expanding window works\n    parcel_df = interpol_deposition(df, qtree, distance_step=deposition_interpolation_distance)\n\n    return parcel_df"
  },
  {
    "objectID": "parcel.html",
    "href": "parcel.html",
    "title": "Parcel",
    "section": "",
    "text": "import geopandas as gpd\n\n\n\nParcel\n\n Parcel (id, crop, soil, deposition, geom, config=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nparcel_df = gpd.read_file('/workspaces/OREFA/Assets/Data/aoi.csv')\n\nImport all files and put in Parcel object Calculate the concentration of product\n\naoi_parcels = []\nfor input_parcel in parcel_df.itertuples():\n    parcel = Parcel(id=parcel.id, crop=parcel.crop, soil = parcel.soil, deposition=parcel.deposition, geom = parcel.geom)\n    parcel.read_config(config_path = '/workspaces/OREFA/Assets/config.ini')\n    parcel.product_conc_prediction(time = 1)\n    #print(perceel.product_concentration)\n    aoi_parcels.append(parcel)\n    \nprint(aoi_parcels[0].product_concentration)"
  }
]